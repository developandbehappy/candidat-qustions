<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шпаргалка для интервьюера</title>
    <style>
        :root {
            --primary-color: #4a6cfa;
            --secondary-color: #34495e;
            --accent-color: #2ecc71;
            --warning-color: #e74c3c;
            --light-color: #f5f7fa;
            --dark-color: #2c3e50;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #ecf0f1;
            color: var(--dark-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
            text-align: center;
        }

        .candidate-form {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .input-group {
            flex: 1;
            min-width: 250px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--secondary-color);
        }

        input, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 108, 250, 0.2);
        }

        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .category-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .category-btn {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 8px 16px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
        }

        .category-btn:hover {
            background-color: #f0f0f0;
        }

        .category-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        .search-input {
            width: 100%;
            padding: 12px 12px 12px 40px;
            border-radius: var(--border-radius);
            border: 1px solid #ddd;
            font-size: 16px;
            transition: var(--transition);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 108, 250, 0.2);
        }

        .question-card {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
        }

        .question-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            align-items: center;
        }

        .question-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .category-tag {
            background-color: #edf2ff;
            color: var(--primary-color);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .question-content {
            margin-bottom: 15px;
        }

        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
            border-left: 4px solid var(--primary-color);
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f8f9fa;
            padding: 2px 5px;
            border-radius: 4px;
        }

        .answer-section {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }

        .answer-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .answer-title i {
            margin-right: 8px;
            transition: var(--transition);
        }

        .answer-title.active i {
            transform: rotate(90deg);
        }

        .answer-content {
            display: none;
        }

        .answer-content.show {
            display: block;
        }

        .answer-option {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .answer-option.correct {
            background-color: rgba(46, 204, 113, 0.2);
        }

        .feedback-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-success {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-danger {
            background-color: var(--warning-color);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-neutral {
            background-color: #e0e0e0;
            color: var(--dark-color);
        }

        .btn-neutral:hover {
            background-color: #d0d0d0;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 14px;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 14px;
            margin-left: 10px;
            font-weight: 500;
        }

        .status-pending {
            background-color: #e0e0e0;
            color: var(--dark-color);
        }

        .status-correct {
            background-color: rgba(46, 204, 113, 0.2);
            color: #27ae60;
        }

        .status-incorrect {
            background-color: rgba(231, 76, 60, 0.2);
            color: #c0392b;
        }

        .summary {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            margin-top: 30px;
        }

        .summary h2 {
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .stat-label {
            color: var(--secondary-color);
            font-size: 14px;
        }

        .empty-state {
            text-align: center;
            padding: 30px;
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .empty-state i {
            font-size: 48px;
            color: #ddd;
            margin-bottom: 15px;
        }

        .empty-state p {
            color: #999;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .category-tag {
                margin-top: 5px;
            }
            
            .feedback-buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }

        .progress-indicator {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-value {
            height: 100%;
            background-color: var(--accent-color);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: var(--secondary-color);
            margin-top: 5px;
        }

        .notes-section {
            margin-top: 15px;
        }

        .notes-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            resize: vertical;
            min-height: 100px;
            transition: var(--transition);
        }

        .notes-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 108, 250, 0.2);
        }
        
        .difficulty-indicator {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .difficulty-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #e0e0e0;
        }
        
        .difficulty-dot.active {
            background-color: var(--primary-color);
        }
        
        .difficulty-easy .difficulty-dot:nth-child(1) {
            background-color: #2ecc71;
        }
        
        .difficulty-medium .difficulty-dot:nth-child(1),
        .difficulty-medium .difficulty-dot:nth-child(2) {
            background-color: #f39c12;
        }
        
        .difficulty-hard .difficulty-dot:nth-child(1),
        .difficulty-hard .difficulty-dot:nth-child(2),
        .difficulty-hard .difficulty-dot:nth-child(3) {
            background-color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Шпаргалка для интервьюера</h1>
            <div class="candidate-form">
                <div class="input-group">
                    <label for="candidate-name">ФИО кандидата</label>
                    <input type="text" id="candidate-name" placeholder="Введите ФИО кандидата">
                </div>
                <div class="input-group">
                    <label for="position">Позиция</label>
                    <select id="position">
                        <option value="junior">Junior Developer</option>
                        <option value="middle">Middle Developer</option>
                        <option value="senior">Senior Developer</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="interview-date">Дата собеседования</label>
                    <input type="date" id="interview-date">
                </div>
            </div>
        </header>

        <div class="filters">
            <div class="input-group">
                <label>Категории вопросов</label>
                <div class="category-buttons">
                    <button class="category-btn active" data-category="all">Все</button>
                    <button class="category-btn" data-category="javascript">JavaScript</button>
                    <button class="category-btn" data-category="typescript">TypeScript</button>
                    <button class="category-btn" data-category="react">React</button>
                    <button class="category-btn" data-category="html">HTML</button>
                    <button class="category-btn" data-category="css">CSS</button>
                </div>
            </div>
        </div>

        <div class="search-container">
            <span class="search-icon">🔍</span>
            <input type="text" class="search-input" id="search-input" placeholder="Поиск вопросов...">
        </div>

        <div class="progress-indicator">
            <div class="progress-bar">
                <div class="progress-value" style="width: 0%"></div>
            </div>
            <div class="progress-text">
                <span id="answered-count">0 из 0 вопросов</span>
                <span id="success-rate">Успешно: 0%</span>
            </div>
        </div>

        <div id="questions-container">
            <!-- Questions will be generated here -->
        </div>

        <div class="summary">
            <h2>Результаты собеседования</h2>
            <div class="summary-stats">
                <div class="stat-box">
                    <div class="stat-value" id="total-questions">0</div>
                    <div class="stat-label">Всего вопросов</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="answered-questions">0</div>
                    <div class="stat-label">Отвечено</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-answers">0</div>
                    <div class="stat-label">Правильно</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="success-percentage">0%</div>
                    <div class="stat-label">Успешность</div>
                </div>
            </div>
            <div class="notes-section">
                <label for="interview-notes">Заметки о собеседовании</label>
                <textarea id="interview-notes" class="notes-input" placeholder="Введите свои заметки о кандидате..."></textarea>
            </div>
        </div>
    </div>

    <script>
        // Данные вопросов
        const questions = [
            {
                id: 1,
                category: "javascript",
                difficulty: "easy",
                title: "Объясните разницу между let, const и var",
                content: "Какие отличия между тремя способами объявления переменных в JavaScript?",
                answer: "var - объявляет переменную с функциональной областью видимости, поднимается (hoisting).<br>let - объявляет переменную с блочной областью видимости, не поднимается.<br>const - объявляет константу (неизменяемую переменную) с блочной областью видимости.",
                status: "pending" // pending, correct, incorrect
            },
            {
                id: 2,
                category: "javascript",
                difficulty: "medium",
                title: "Что такое замыкания (closures)?",
                content: "Объясните концепцию замыканий в JavaScript и приведите пример использования.",
                answer: "Замыкание - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Замыкание даёт доступ к переменным из внешней функции даже после того, как внешняя функция завершила своё выполнение.<br><br>Пример:<pre>function createCounter() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2</pre>",
                status: "pending"
            },
            {
                id: 3,
                category: "javascript",
                difficulty: "medium",
                title: "Объясните Event Loop в JavaScript",
                content: "Как работает Event Loop? Что такое стек вызовов, очередь задач и микрозадач?",
                answer: "Event Loop (цикл событий) - это механизм, который позволяет JavaScript выполнять неблокирующие операции, несмотря на то, что JavaScript однопоточный.<br><br>- Call Stack (стек вызовов) - структура данных, которая хранит информацию о выполняемых функциях.<br>- Callback Queue (очередь задач) - содержит функции обратного вызова, готовые к выполнению.<br>- Microtask Queue (очередь микрозадач) - имеет приоритет над обычной очередью, содержит задачи, созданные Promise.then/catch/finally и queueMicrotask.<br><br>Цикл событий проверяет, пуст ли стек вызовов. Если да, сначала выполняются все микрозадачи, затем берется первая задача из очереди задач и выполняется.",
                status: "pending"
            },
            {
                id: 4,
                category: "javascript",
                difficulty: "hard",
                title: "Что такое прототипное наследование?",
                content: "Объясните прототипное наследование в JavaScript и как его можно использовать?",
                answer: "Прототипное наследование - механизм, который позволяет объектам наследовать свойства и методы от других объектов.<br><br>Каждый объект в JavaScript имеет свойство __proto__, которое указывает на прототип этого объекта. Когда мы пытаемся получить доступ к свойству объекта, JS сначала ищет его в самом объекте, затем в его прототипе, и так далее по цепочке прототипов.<br><br>Пример:<pre>function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  console.log(`${this.name} издает звук`);\n};\n\nfunction Dog(name) {\n  Animal.call(this, name);\n}\n\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nDog.prototype.bark = function() {\n  console.log('Гав-гав!');\n};\n\nconst dog = new Dog('Бобик');\ndog.speak(); // Бобик издает звук\ndog.bark(); // Гав-гав!</pre>",
                status: "pending"
            },
            {
                id: 5,
                category: "javascript",
                difficulty: "medium",
                title: "Методы массивов в JavaScript",
                content: "Объясните разницу между методами map, filter, reduce и forEach.",
                answer: "<ul><li><strong>map()</strong> - возвращает новый массив с результатом вызова указанной функции для каждого элемента массива.<br><pre>const numbers = [1, 2, 3];\nconst doubled = numbers.map(x => x * 2); // [2, 4, 6]</pre></li><li><strong>filter()</strong> - создаёт новый массив со всеми элементами, прошедшими проверку.<br><pre>const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(x => x % 2 === 0); // [2, 4]</pre></li><li><strong>reduce()</strong> - применяет функцию к аккумулятору и каждому элементу массива (слева направо), сводя его к единому значению.<br><pre>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, val) => acc + val, 0); // 10</pre></li><li><strong>forEach()</strong> - выполняет указанную функцию один раз для каждого элемента в массиве, ничего не возвращает.<br><pre>const numbers = [1, 2, 3];\nnumbers.forEach(x => console.log(x)); // 1, 2, 3</pre></li></ul>",
                status: "pending"
            },
            {
                id: 6,
                category: "typescript",
                difficulty: "medium",
                title: "Типы в TypeScript",
                content: "Объясните разницу между interface и type в TypeScript. Когда следует использовать каждый из них?",
                answer: "<strong>Interface:</strong><br>- Может быть расширен через объявление с тем же именем (declaration merging)<br>- Предназначен в основном для описания формы объектов<br>- Более объектно-ориентированный подход<br><pre>interface User {\n  name: string;\n  age: number;\n}\n\ninterface User {\n  email: string; // расширение существующего interface\n}</pre><br><strong>Type:</strong><br>- Не может быть изменен после создания<br>- Более гибкий, может представлять примитивы, союзы, пересечения и другие продвинутые типы<br>- Лучше для создания типов-синонимов и сложных типов<br><pre>type User = {\n  name: string;\n  age: number;\n};\n\ntype ID = string | number; // союзный тип\ntype UserWithID = User & { id: ID }; // пересечение типов</pre><br><strong>Когда что использовать:</strong><br>- Interface: для публичных API, при работе с классами, когда нужно расширение<br>- Type: для сложных типов, функциональных типов, когда нужны union или пересечения типов",
                status: "pending"
            },
            {
                id: 7,
                category: "typescript",
                difficulty: "hard",
                title: "Generics в TypeScript",
                content: "Что такое Generics в TypeScript и как их использовать?",
                answer: "Generics (обобщения) - это способ создания компонентов, которые могут работать с различными типами данных, сохраняя при этом типобезопасность.<br><br>Основное преимущество: возможность создания переиспользуемого кода, который работает с разными типами, но при этом сохраняет информацию о типе.<br><pre>// Обобщённая функция\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst num = identity<number>(42);    // тип: number\nconst str = identity('hello');       // тип: string (автоматический вывод)\n\n// Обобщённый интерфейс\ninterface Box<T> {\n  value: T;\n}\n\nconst numberBox: Box<number> = { value: 42 };\nconst stringBox: Box<string> = { value: 'hello' };\n\n// Обобщённый класс\nclass Queue<T> {\n  private data: T[] = [];\n  \n  push(item: T): void {\n    this.data.push(item);\n  }\n  \n  pop(): T | undefined {\n    return this.data.shift();\n  }\n}\n\nconst numberQueue = new Queue<number>();</pre>",
                status: "pending"
            },
            {
                id: 8,
                category: "react",
                difficulty: "medium",
                title: "Управление состоянием в React",
                content: "Объясните различные способы управления состоянием в React-приложениях.",
                answer: "<strong>1. Локальное состояние (useState):</strong><br><pre>function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}</pre><br><strong>2. Состояние с помощью useReducer:</strong><br><pre>function reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n    </div>\n  );\n}</pre><br><strong>3. Контекст (useContext):</strong><br><pre>const CountContext = createContext();\n\nfunction CountProvider({ children }) {\n  const [count, setCount] = useState(0);\n  return (\n    <CountContext.Provider value={{ count, setCount }}>\n      {children}\n    </CountContext.Provider>\n  );\n}\n\nfunction Counter() {\n  const { count, setCount } = useContext(CountContext);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}</pre><br><strong>4. Внешние библиотеки управления состоянием:</strong><br>- Redux - централизованное хранилище с actions и reducers<br>- MobX - реактивное программирование с наблюдаемыми объектами<br>- Recoil - атомарный подход к управлению состоянием<br>- Zustand - простое API с хуками<br>- Jotai - атомарное состояние, похоже на Recoil, но с более простым API",
                status: "pending"
            },
            {
                id: 9,
                category: "react",
                difficulty: "hard",
                title: "React и рендеринг",
                content: "Как React определяет, что нужно перерендерить? Объясните процесс примирения (reconciliation) и алгоритм сравнения (diffing algorithm).",
answer: "<strong>Когда происходит перерендеринг:</strong><br>1. Изменение состояния (setState/useState)<br>2. Изменение пропсов<br>3. Вызов forceUpdate()<br>4. Перерендеринг родительского компонента<br><br><strong>Процесс примирения (reconciliation):</strong><br>Когда React обновляет DOM, он сначала запускает алгоритм сравнения (diffing), чтобы определить, что изменилось. Этот процесс происходит в памяти с использованием Virtual DOM.<br><br><strong>Алгоритм сравнения:</strong><br>1. <strong>Элементы разного типа</strong> - React полностью демонтирует старое дерево и строит новое<br>2. <strong>Элементы одного типа</strong> - React смотрит на атрибуты и обновляет только изменившиеся<br>3. <strong>Компоненты</strong> - когда компонент обновляется, его экземпляр остается тем же, сохраняя состояние<br>4. <strong>Рекурсия для дочерних элементов</strong> - React проходит через все дочерние элементы<br><br><strong>Ключи (keys):</strong><br>React использует ключи, чтобы определить, какие элементы массива изменились, добавились или удалились.<br><pre>function List({ items }) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>{item.text}</li>\n      ))}\n    </ul>\n  );\n}</pre>",
                status: "pending"
            },
            {
                id: 10,
                category: "react",
                difficulty: "medium",
                title: "Хуки React",
                content: "Объясните основные хуки в React и их применение.",
                answer: "<strong>useState</strong> - управление локальным состоянием<br><pre>const [state, setState] = useState(initialState);</pre><br><strong>useEffect</strong> - побочные эффекты (запросы API, подписки и т.д.)<br><pre>useEffect(() => {\n  // Выполняется после рендера\n  return () => {\n    // Очистка (необязательно)\n  };\n}, [dependencies]);</pre><br><strong>useContext</strong> - доступ к контексту React<br><pre>const value = useContext(MyContext);</pre><br><strong>useReducer</strong> - более сложное состояние с логикой редуктора<br><pre>const [state, dispatch] = useReducer(reducer, initialArg, init);</pre><br><strong>useCallback</strong> - мемоизация функций<br><pre>const memoizedCallback = useCallback(\n  () => doSomething(a, b),\n  [a, b]\n);</pre><br><strong>useMemo</strong> - мемоизация вычисляемых значений<br><pre>const memoizedValue = useMemo(\n  () => computeExpensiveValue(a, b),\n  [a, b]\n);</pre><br><strong>useRef</strong> - создает мутабельный объект с свойством .current<br><pre>const inputRef = useRef(null);</pre><br><strong>useLayoutEffect</strong> - как useEffect, но синхронно после всех DOM-мутаций<br><strong>useImperativeHandle</strong> - настраивает значение экземпляра, которое выставляется родительским компонентам при использовании ref<br><strong>useDebugValue</strong> - отображает метку для пользовательских хуков в React DevTools",
                status: "pending"
            },
            {
                id: 11,
                category: "html",
                difficulty: "easy",
                title: "Семантический HTML",
                content: "Что такое семантический HTML и почему он важен?",
                answer: "<strong>Семантический HTML</strong> - это использование HTML-тегов, которые описывают своё содержимое и его смысл, а не только его внешний вид.<br><br><strong>Примеры семантических тегов:</strong><br>- <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;nav&gt;</code><br>- <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;aside&gt;</code><br>- <code>&lt;figure&gt;</code>, <code>&lt;figcaption&gt;</code><br>- <code>&lt;main&gt;</code>, <code>&lt;time&gt;</code><br><br><strong>Преимущества:</strong><br>1. <strong>Доступность</strong> - ассистивные технологии лучше интерпретируют семантические теги<br>2. <strong>SEO</strong> - поисковые системы лучше понимают контент и его значимость<br>3. <strong>Поддержка кода</strong> - более читаемый и структурированный код<br>4. <strong>Консистентность</strong> - стандартизированный подход к разметке<br><br><strong>Пример:</strong><br><pre>&lt;!-- Несемантичный HTML --&gt;\n&lt;div class=\"header\"&gt;\n  &lt;div class=\"logo\"&gt;Мой сайт&lt;/div&gt;\n  &lt;div class=\"nav\"&gt;\n    &lt;div class=\"nav-item\"&gt;Главная&lt;/div&gt;\n    &lt;div class=\"nav-item\"&gt;О нас&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Семантичный HTML --&gt;\n&lt;header&gt;\n  &lt;h1&gt;Мой сайт&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;ul&gt;\n      &lt;li&gt;&lt;a href=\"/\"&gt;Главная&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/about\"&gt;О нас&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/nav&gt;\n&lt;/header&gt;</pre>",
                status: "pending"
            },
            {
                id: 12,
                category: "html",
                difficulty: "medium",
                title: "HTML5 API",
                content: "Расскажите о различных API, представленных в HTML5.",
                answer: "HTML5 представил множество мощных API для разработки современных веб-приложений:<br><br><strong>1. Storage API</strong><br>- <code>localStorage</code> - хранение данных без ограничения времени<br>- <code>sessionStorage</code> - хранение данных в рамках сессии<br><pre>// Пример использования localStorage\nlocalStorage.setItem('key', 'value');\nconst value = localStorage.getItem('key');</pre><br><strong>2. Canvas API</strong> - для рисования графики<br><pre>&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;\n\n&lt;script&gt;\n  const canvas = document.getElementById('myCanvas');\n  const ctx = canvas.getContext('2d');\n  ctx.fillStyle = 'red';\n  ctx.fillRect(10, 10, 50, 50);\n&lt;/script&gt;</pre><br><strong>3. Geolocation API</strong> - для получения географического положения<br><pre>navigator.geolocation.getCurrentPosition(\n  position => {\n    console.log(`Широта: ${position.coords.latitude}`);\n    console.log(`Долгота: ${position.coords.longitude}`);\n  },\n  error => {\n    console.error(`Ошибка: ${error.message}`);\n  }\n);</pre><br><strong>4. Drag and Drop API</strong> - для перетаскивания элементов<br><strong>5. Web Workers</strong> - выполнение скриптов в фоновых потоках<br><strong>6. WebSockets</strong> - двусторонняя связь с сервером<br><strong>7. History API</strong> - манипулирование историей браузера<br><strong>8. File API</strong> - для работы с файлами<br><strong>9. IndexedDB</strong> - клиентская NoSQL база данных<br><strong>10. Web Audio API</strong> - для создания и манипулирования звуком<br><strong>11. Media Capture and Streams</strong> - доступ к камере и микрофону<br><strong>12. Service Workers</strong> - для создания офлайн-функциональности",
                status: "pending"
            },
            {
                id: 13,
                category: "css",
                difficulty: "medium",
                title: "CSS - Flexbox и Grid",
                content: "Объясните разницу между Flexbox и Grid и когда лучше использовать каждый из них.",
                answer: "<strong>Flexbox (Flexible Box):</strong><br>- Одномерная система компоновки (работает либо по строкам, либо по столбцам)<br>- Идеален для компонентов пользовательского интерфейса и макетов небольшого масштаба<br>- Отлично подходит для выравнивания элементов внутри контейнера<br><br><strong>Основные свойства Flexbox:</strong><br>- <code>display: flex</code><br>- <code>flex-direction</code>, <code>flex-wrap</code>, <code>flex-flow</code><br>- <code>justify-content</code>, <code>align-items</code>, <code>align-content</code><br>- <code>flex</code>, <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code><br><br><strong>CSS Grid:</strong><br>- Двумерная система компоновки (работает одновременно по строкам и столбцам)<br>- Идеален для макетов всей страницы и сложных структур<br>- Отлично подходит для создания сеток и выравнивания элементов по обеим осям<br><br><strong>Основные свойства Grid:</strong><br>- <code>display: grid</code><br>- <code>grid-template-columns</code>, <code>grid-template-rows</code><br>- <code>grid-template-areas</code>, <code>grid-template</code><br>- <code>grid-column</code>, <code>grid-row</code>, <code>grid-area</code><br>- <code>gap</code>, <code>column-gap</code>, <code>row-gap</code><br><br><strong>Когда использовать Flexbox:</strong><br>- Для навигационных меню<br>- Для центрирования элементов<br>- Для макетов, где есть один ряд или столбец элементов<br>- Когда элементы должны заполнять доступное пространство пропорционально<br><br><strong>Когда использовать Grid:</strong><br>- Для полного макета страницы<br>- Для элементов, выровненных по строкам и столбцам одновременно<br>- Для сложных несимметричных макетов<br>- Когда нужно точно позиционировать элементы в двумерной сетке<br><br><strong>Лучшие практики:</strong><br>- Часто можно использовать оба: Grid для основного макета и Flexbox для компонентов внутри<br>- Grid лучше для двумерных макетов, Flexbox для одномерных<br>- При сомнениях, начните с Flexbox и переходите к Grid, когда макет становится сложнее",
                status: "pending"
            },
            {
                id: 14,
                category: "css",
                difficulty: "hard",
                title: "CSS-архитектура",
                content: "Опишите различные методологии CSS-архитектуры (BEM, OOCSS, SMACSS и т.д.) и их преимущества.",
                answer: "<strong>1. BEM (Block, Element, Modifier)</strong><br><br>Структура именования:<br>- <code>block</code> - автономный компонент<br>- <code>block__element</code> - часть блока, выполняющая определенную функцию<br>- <code>block--modifier</code> / <code>block__element--modifier</code> - варианты блока/элемента<br><pre>.card {}\n.card__image {}\n.card__title {}\n.card--featured {}</pre><br><strong>Преимущества:</strong><br>- Понятная, модульная структура<br>- Устраняет проблемы специфичности<br>- Хорошо масштабируется<br><br><strong>2. OOCSS (Object-Oriented CSS)</strong><br><br>Принципы:<br>- Разделение структуры и оформления<br>- Разделение контейнера и содержимого<br><pre>/* Структура */\n.btn {\n  display: inline-block;\n  padding: 5px 10px;\n  border-radius: 3px;\n}\n\n/* Оформление */\n.btn-primary {\n  background-color: blue;\n  color: white;\n}</pre><br><strong>Преимущества:</strong><br>- Переиспользуемость кода<br>- Меньший размер файлов CSS<br>- Консистентность интерфейса<br><br><strong>3. SMACSS (Scalable and Modular Architecture for CSS)</strong><br><br>Категории правил:<br>- Base - стили по умолчанию для HTML-элементов<br>- Layout - основные компоненты макета<br>- Module - модули интерфейса<br>- State - состояния элементов<br>- Theme - темы (если есть)<br><pre>/* Base */\nbutton { /* ... */ }\n\n/* Layout */\n.l-header { /* ... */ }\n\n/* Module */\n.nav { /* ... */ }\n\n/* State */\n.is-active { /* ... */ }</pre><br><strong>Преимущества:</strong><br>- Хорошо структурированный код<br>- Удобно для больших проектов<br>- Ясные правила модификации<br><br><strong>4. ITCSS (Inverted Triangle CSS)</strong><br><br>Многослойная архитектура, организованная от общего к конкретному:<br>1. Settings - переменные<br>2. Tools - миксины и функции<br>3. Generic - сброс/нормализация<br>4. Elements - базовые стили<br>5. Objects - несемантические классы<br>6. Components - компоненты интерфейса<br>7. Utilities - утилитарные классы<br><br><strong>5. Atomic CSS</strong><br><br>Использование маленьких, односвойственных классов:<br><pre>.mt-10 { margin-top: 10px; }\n.p-20 { padding: 20px; }\n.bg-blue { background-color: blue; }</pre><br><strong>Преимущества:</strong><br>- Минимизирует дублирование CSS<br>- Низкая специфичность<br>- Быстрая разработка<br><br><strong>Выбор подхода</strong> зависит от размера проекта, команды и конкретных требований. Многие проекты используют гибридный подход, сочетающий элементы разных методологий.",
                status: "pending"
            },
            {
                id: 15,
                category: "javascript",
                difficulty: "hard",
                title: "Асинхронное программирование в JavaScript",
                content: "Опишите различные способы работы с асинхронным кодом в JavaScript и их эволюцию.",
                answer: "<strong>1. Callbacks (колбэки)</strong><br>Самый ранний подход, функции передаются в качестве аргументов и вызываются после завершения операции.<br><pre>function fetchData(callback) {\n  setTimeout(() => {\n    callback(null, 'Data received');\n  }, 1000);\n}\n\nfetchData((error, data) => {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log(data);  // 'Data received'\n  }\n});</pre><br><strong>Проблемы:</strong> Callback hell (пирамида вложенных колбэков), сложность обработки ошибок.<br><br><strong>2. Promises (промисы)</strong><br>Представляют асинхронную операцию, которая может завершиться успешно или с ошибкой.<br><pre>function fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Data received');\n      // или reject(new Error('Failed to fetch data'));\n    }, 1000);\n  });\n}\n\nfetchData()\n  .then(data => {\n    console.log(data);  // 'Data received'\n    return processData(data);\n  })\n  .then(processedData => {\n    console.log(processedData);\n  })\n  .catch(error => {\n    console.error(error);\n  });</pre><br><strong>Преимущества:</strong> Цепочки промисов, централизованная обработка ошибок.<br><br><strong>3. Async/Await</strong><br>Синтаксический сахар над промисами, позволяющий писать асинхронный код в синхронном стиле.<br><pre>async function getData() {\n  try {\n    const data = await fetchData();  // fetchData возвращает Promise\n    console.log(data);  // 'Data received'\n    \n    const processedData = await processData(data);\n    console.log(processedData);\n    \n    return processedData;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\ngetData();</pre><br><strong>Преимущества:</strong> Более чистый и читаемый код, лучшая обработка ошибок с try/catch.<br><br><strong>4. Generators и yield</strong><br>Могут приостанавливать и возобновлять свое выполнение.<br><pre>function* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nconst generator = generateSequence();\n\nconsole.log(generator.next().value);  // 1\nconsole.log(generator.next().value);  // 2\nconsole.log(generator.next().value);  // 3</pre><br><strong>5. Observable (RxJS)</strong><br>Представляют потоки данных, на которые можно подписаться.<br><pre>import { Observable } from 'rxjs';\n\nconst observable = new Observable(subscriber => {\n  subscriber.next(1);\n  subscriber.next(2);\n  setTimeout(() => {\n    subscriber.next(3);\n    subscriber.complete();\n  }, 1000);\n});\n\nobservable.subscribe({\n  next: x => console.log('получено значение ' + x),\n  error: err => console.error('ошибка: ' + err),\n  complete: () => console.log('завершено')\n});</pre><br><strong>Современные подходы и паттерны:</strong><br>- Параллельное выполнение промисов с Promise.all(), Promise.race(), Promise.allSettled()<br>- Комбинирование async/await с map, reduce и другими функциями высшего порядка<br>- Использование библиотек для управления сложными асинхронными потоками (Redux-Saga, Redux-Observable)",
                status: "pending"
            }
        ];

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            renderQuestions(questions);
            setupEventListeners();
            updateProgress();
            updateSummary();
        });

        // Функция для рендеринга вопросов
        function renderQuestions(questionsToRender) {
            const container = document.getElementById('questions-container');
            container.innerHTML = '';

            if (questionsToRender.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i>📝</i>
                        <p>Нет вопросов, соответствующих критериям поиска.</p>
                    </div>
                `;
                return;
            }

            questionsToRender.forEach(question => {
                let statusClass = 'status-pending';
                let statusText = 'Не задан';
                
                if (question.status === 'correct') {
                    statusClass = 'status-correct';
                    statusText = 'Правильно';
                } else if (question.status === 'incorrect') {
                    statusClass = 'status-incorrect';
                    statusText = 'Неправильно';
                }

                // Определение иконок для сложности
                let difficultyHTML = `
                    <div class="difficulty-indicator difficulty-${question.difficulty}">
                        <div class="difficulty-dot"></div>
                        <div class="difficulty-dot"></div>
                        <div class="difficulty-dot"></div>
                    </div>
                `;

                const card = document.createElement('div');
                card.className = 'question-card';
                card.dataset.id = question.id;
                card.innerHTML = `
                    <div class="question-header">
                        <div class="question-title">
                            ${question.title}
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </div>
                        <span class="category-tag">${getCategoryName(question.category)}</span>
                    </div>
                    <div class="question-content">
                        ${question.content}
                        ${difficultyHTML}
                    </div>
                    <div class="answer-section">
                        <div class="answer-title">
                            <i>►</i> Смотреть ответ
                        </div>
                        <div class="answer-content">
                            ${question.answer}
                        </div>
                    </div>
                    <div class="feedback-buttons">
                        <button class="btn btn-success" data-action="correct" data-id="${question.id}">
                            <i>✓</i> Правильный ответ
                        </button>
                        <button class="btn btn-danger" data-action="incorrect" data-id="${question.id}">
                            <i>✗</i> Неправильный ответ
                        </button>
                        <button class="btn btn-neutral" data-action="reset" data-id="${question.id}">
                            <i>↻</i> Сбросить
                        </button>
                    </div>
                `;
                container.appendChild(card);
            });

            // Настройка обработчиков для переключения видимости ответов
            document.querySelectorAll('.answer-title').forEach(title => {
                title.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    content.classList.toggle('show');
                });
            });
        }

        // Функция для настройки обработчиков событий
        function setupEventListeners() {
            // Обработка фильтрации по категориям
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    filterQuestions();
                });
            });

            // Обработка поиска
            document.getElementById('search-input').addEventListener('input', filterQuestions);

            // Делегирование для кнопок обратной связи
            document.getElementById('questions-container').addEventListener('click', function(event) {
                const target = event.target.closest('[data-action]');
                if (!target) return;

                const action = target.dataset.action;
                const id = parseInt(target.dataset.id);
                
                // Находим вопрос по id
                const questionIndex = questions.findIndex(q => q.id === id);
                if (questionIndex === -1) return;
                
                // Обновляем статус вопроса
                if (action === 'correct') {
                    questions[questionIndex].status = 'correct';
                } else if (action === 'incorrect') {
                    questions[questionIndex].status = 'incorrect';
                } else if (action === 'reset') {
                    questions[questionIndex].status = 'pending';
                }
                
                // Перерисовываем вопросы и обновляем статистику
                filterQuestions();
                updateProgress();
                updateSummary();
            });
        }

        // Функция для фильтрации вопросов
        function filterQuestions() {
            const activeCategory = document.querySelector('.category-btn.active').dataset.category;
            const searchQuery = document.getElementById('search-input').value.toLowerCase();
            
            let filteredQuestions = questions;
            
            // Фильтрация по категории
            if (activeCategory !== 'all') {
                filteredQuestions = filteredQuestions.filter(q => q.category === activeCategory);
            }
            
            // Фильтрация по поисковому запросу
            if (searchQuery) {
                filteredQuestions = filteredQuestions.filter(q => 
                    q.title.toLowerCase().includes(searchQuery) || 
                    q.content.toLowerCase().includes(searchQuery)
                );
            }
            
            renderQuestions(filteredQuestions);
        }

        // Функция для обновления прогресса
        function updateProgress() {
            const total = questions.length;
            const answered = questions.filter(q => q.status !== 'pending').length;
            const correct = questions.filter(q => q.status === 'correct').length;
            
            const successRate = total > 0 ? Math.round((correct / total) * 100) : 0;
            
            document.getElementById('answered-count').textContent = `${answered} из ${total} вопросов`;
            document.getElementById('success-rate').textContent = `Успешно: ${successRate}%`;
            
            const progressBar = document.querySelector('.progress-value');
            progressBar.style.width = `${answered / total * 100}%`;
        }

        // Функция для обновления сводной информации
        function updateSummary() {
            const total = questions.length;
            const answered = questions.filter(q => q.status !== 'pending').length;
            const correct = questions.filter(q => q.status === 'correct').length;
            
            const successRate = answered > 0 ? Math.round((correct / answered) * 100) : 0;
            
            document.getElementById('total-questions').textContent = total;
            document.getElementById('answered-questions').textContent = answered;
            document.getElementById('correct-answers').textContent = correct;
            document.getElementById('success-percentage').textContent = `${successRate}%`;
        }

        // Функция для получения читаемого названия категории
        function getCategoryName(category) {
            const categoryNames = {
                'javascript': 'JavaScript',
                'typescript': 'TypeScript',
                'react': 'React',
                'html': 'HTML',
                'css': 'CSS'
            };
            return categoryNames[category] || category;
        }
    </script>
</body>
</html>
